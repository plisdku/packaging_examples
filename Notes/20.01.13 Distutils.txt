Distutils
=========

https://docs.python.org/3/install/index.html

Python 2.0 added `distutils` to standard library.  Standard way to convert Python _projects_ into Linux distro _packages_, and for system admins to install these directly onto target systems.

Tightly coupling the build system and package installer to the language runtime release cycle started to seem like a bad idea (I guess this is because `distutils` was _in the standard library_).  Enter `pip` installation and `setuptools` build system, rather than direct use of `distutils`.

Got that?
- `pip` is for installation
- `setuptools` is for building

How to recognize `distutils`-based source distributions
-------------------------------------------------------

Archive has distribution name and a version: `foo-1.0.tar.gz`.  Unpacks to similarly-named directory like `foo-1.0`.  It contains `setup.py`, `README.txt` or something.  Then you can install: `python setup.py install`.

Standard build and install
--------------------------

Run the setup command from the distribution root directory.

Setup commands: split up the job
--------------------------------

Now we have the famous "commands".

```
python setup.py build
python setup.py install # runs build, which has no work left to do of course
```

If you get into distributing your own Python modules and extensions, you'll run lots of individual distutils commands on their own.  Ok, I'm oriented.

### Building

`build` puts files to install into a _build directory_.  This is `$ROOT/build` by default.  To change the build directory,
```
python setup.py build --build-base=/path/to/pybuild/foo-1.0
```
Or do this permanently with a directive in your _system distutils configuration files_ or _personal distutils configuration files_.  Note: read about distutils configuration files.

#### Build layout

For _pure module distributions_:
```
$ROOT/build/lib/
```

and for distributions with any C/C++ extensions,
```
$ROOT/build/lib.<plat>    # all Python modules (pure Python and extensions)
                          # that will be installed
$ROOT/build/temp.<plat>   # temporary files generated by the compile/link
                          # process that don't actually get installed
```

They claim more directories will be added to handle Python scripts, docs, binary exes, etc.

---
_My example: I went into `extension_vanilla` and ran `python3 setup.py build` and the `build` directory popped out looking like this:_
```
build
├── lib.macosx-10.13-x86_64-3.7
│   ├── nativepkg
│   │   ├── __init__.py
│   │   ├── interface.cpp
│   │   ├── interface.hpp
│   │   └── interface.py
│   ├── nativepkg.cpython-37m-darwin.so
│   └── pythonpkg
│       ├── __init__.py
│       └── hello.py
└── temp.macosx-10.13-x86_64-3.7
    └── src
        └── nativepkg
            └── interface.o
```

_What I don't understand is why the .cpp and .hpp files are also in there._

---

### Installation

Copy everything under `build/lib` or `build/lib.<plat>` to your chosen installation directory.  _Technically_ packages could be installed in different places depending on whether they are pure Python or not.  The pure Python ones usually wind up in `sys.prefix` subdirs and the impure ones in `sys.exec_prefix` subdirs.  But on Linux those are generally BOTH `/usr` or `/usr/local`.

My homebrew-installed iPython 3 says
```
In [5]: sys.prefix                                                              
Out[5]: '/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7'

In [6]: sys.exec_prefix                                                         
Out[6]: '/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7'
```

and my built-in Python 2.7 says
```
>>> sys.prefix
'/System/Library/Frameworks/Python.framework/Versions/2.7'
>>> sys.exec_prefix
'/System/Library/Frameworks/Python.framework/Versions/2.7'
```

---
_My example continued.  I ran `python3 setup.py install` and things appeared in my `site-packages`:_
```
extension_vanilla-0.0.1-py3.7-macosx-10.13-x86_64.egg/
├── EGG-INFO
│   ├── PKG-INFO
│   ├── SOURCES.txt
│   ├── dependency_links.txt
│   ├── native_libs.txt
│   ├── not-zip-safe
│   └── top_level.txt
├── __pycache__
│   └── nativepkg.cpython-37.pyc
├── nativepkg
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   └── interface.cpython-37.pyc
│   ├── interface.cpp
│   ├── interface.hpp
│   └── interface.py
├── nativepkg.cpython-37m-darwin.so
├── nativepkg.py
└── pythonpkg
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   └── hello.cpython-37.pyc
    └── hello.py
```

_So, I have the C++ source and header files in there too now.  I'm not sure I wanted this._

_I also ran `python3 setup.py --user --prefix=` (this is weird but correct) and my crap got put into here:_
```
/Users/paul/Library/Python/3.7/lib/python/site-packages/extension_vanilla-0.0.1-py3.7-macosx-10.13-x86_64.egg
```

Don't do this though.  Don't install with `setup.py` at all maybe.  It uses `easy-install.pth` and I had to uninstall it by hand.

---


Building C and C++ Extensions with distutils
============================================

https://docs.python.org/3/extending/building.html#building-c-and-c-extensions-with-distutils

Distutils supports creation of binary packages [Paul says: see about setuptools, wheels, all that], user's don't necessarily need a compiler and distutils to install your extensions.




#
